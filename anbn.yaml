states: [q0, q1, q2, q3, qf]
input_alphabet: [a, b]
tape_alphabet: [a, b, X, Y, B, '$']
cache_alphabet: [B]
initial_state: q0
initial_cache: B
accept_states: [qf]

# Accept a^n b^n (equal number of a's followed by b's)
# Algorithm:
# 1. Mark leftmost 'a' with X
# 2. Find leftmost 'b' and mark with Y
# 3. Go back to start
# 4. Repeat until all marked
# 5. Verify and accept

transitions:
  # q0: Find leftmost unmarked 'a'
  - state: q0
    read: ['$', B]
    write: ['$', B]
    move: R
    next: q0
  
  - state: q0
    read: [X, B]
    write: [X, B]
    move: R
    next: q0
  
  - state: q0
    read: [a, B]
    write: [X, B]
    move: R
    next: q1
  
  # Only Y's left, verify
  - state: q0
    read: [Y, B]
    write: [Y, B]
    move: R
    next: q3
  
  # Empty string
  - state: q0
    read: [B, B]
    write: [B, B]
    move: R
    next: qf
  
  # q1: Find leftmost unmarked 'b'
  - state: q1
    read: [a, B]
    write: [a, B]
    move: R
    next: q1
  
  - state: q1
    read: [Y, B]
    write: [Y, B]
    move: R
    next: q1
  
  - state: q1
    read: [b, B]
    write: [Y, B]
    move: L
    next: q2
  
  # q2: Go back to start
  - state: q2
    read: [a, B]
    write: [a, B]
    move: L
    next: q2
  
  - state: q2
    read: [Y, B]
    write: [Y, B]
    move: L
    next: q2
  
  - state: q2
    read: [X, B]
    write: [X, B]
    move: L
    next: q2
  
  - state: q2
    read: ['$', B]
    write: ['$', B]
    move: R
    next: q0
  
  # q3: Verify only Y's and B remain
  - state: q3
    read: [Y, B]
    write: [Y, B]
    move: R
    next: q3
  
  - state: q3
    read: [B, B]
    write: [B, B]
    move: R
    next: qf

inputs:
  - "aaabbb"
  - "aaaabbbb"
  - "aaaabb"
  - "ababab"